rule CustomAssemblyPattern
{
    meta:
        description = "Comprehensive detection of specific custom assembly instructions based on provided disassembly, including Emotet evasion and anti-debugging routines"
        author = "Generated by ChatGPT"
        date = "2024-11-15"
        reference = "Sample comprehensive assembly sequence"

    strings:
        // Matching a comprehensive set of instructions provided in the disassembly, avoiding hardcoded relative addresses
        $call_rel_offset = { E8 ?? ?? ?? ?? }                     // call instruction with any possible relative offset
        $pop_eax = { 58 }                                         // pop eax
        $mov_ebx_eax = { 89 C3 }                                  // mov ebx, eax
        $add_eax_dynamic = { 05 ?? ?? ?? ?? }                     // add eax, dynamic immediate value
        $add_ebx_dynamic = { 81 C3 ?? ?? ?? ?? }                  // add ebx, dynamic immediate value
        $push_1 = { 68 01 00 00 00 }                              // push 1
        $push_5 = { 68 05 00 00 00 }                              // push 5
        $push_ebx = { 53 }                                        // push ebx
        $push_value_any = { 68 ?? ?? ?? ?? }                      // push dynamic value
        $push_eax = { 50 }                                        // push eax
        $call_any_offset = { E8 ?? ?? ?? ?? }                     // call with any relative offset
        $add_esp_dynamic = { 83 C4 ?? }                           // add esp, dynamic immediate value
        $ret = { C3 }                                             // ret
        $sub_esp_dynamic = { 83 EC ?? }                           // sub esp, dynamic immediate value
        $and_dword_ptr_esp_dynamic_0 = { 83 64 24 ?? 00 }         // and dword ptr [esp + dynamic offset], 0
        $mov_ecx_dynamic = { B9 ?? ?? ?? ?? }                     // mov ecx, dynamic immediate value
        $push_ebp = { 55 }                                        // push ebp
        $push_esi = { 56 }                                        // push esi
        $push_edi = { 57 }                                        // push edi
        $xor_esi_esi = { 33 F6 }                                  // xor esi, esi
        $call_dynamic_offset = { E8 ?? ?? ?? ?? }                 // call with dynamic offset
        $mov_dword_ptr_esp_dynamic_eax = { 89 44 24 ?? }          // mov dword ptr [esp + dynamic offset], eax
        $mov_ebp_eax = { 8B E8 }                                  // mov ebp, eax
        $cmp_dword_ptr_edi_pe_signature = { 81 3F 50 45 00 00 }   // cmp dword ptr [edi], 0x4550 (PE signature)
        $je_dynamic = { 74 ?? }                                   // je with dynamic offset
        $xor_eax_eax = { 33 C0 }                                  // xor eax, eax
        $jmp_any_offset = { E9 ?? ?? ?? ?? }                      // jmp with any relative offset
        $cmp_word_ptr_edi_dynamic_ax = { 66 39 47 ?? }            // cmp word ptr [edi + dynamic offset], ax
        $jne_dynamic = { 75 ?? }                                  // jne with dynamic offset
        $test_byte_ptr_edi_dynamic_1 = { F6 47 ?? 01 }            // test byte ptr [edi + dynamic offset], 1
        $movzx_edx_word_ptr_edi_dynamic = { 0F B7 57 ?? }         // movzx edx, word ptr [edi + dynamic offset]
        $movzx_eax_word_ptr_edi_dynamic = { 0F B7 47 ?? }         // movzx eax, word ptr [edi + dynamic offset]
        $test_edx_edx = { 85 D2 }                                 // test edx, edx
        $je_dynamic_2 = { 74 ?? }                                 // je with dynamic offset
        $lea_ecx_edi_dynamic = { 8D 4F ?? }                       // lea ecx, [edi + dynamic offset]
        $add_ecx_eax = { 03 C8 }                                  // add ecx, eax
        $cmp_dword_ptr_ecx_dynamic_0 = { 83 79 ?? 00 }            // cmp dword ptr [ecx + dynamic offset], 0
        $jne_dynamic_3 = { 75 ?? }                                // jne with dynamic offset
        $add_eax_dword_ptr_edi_dynamic = { 03 47 ?? }             // add eax, dword ptr [edi + dynamic offset]
        $cmp_eax_esi = { 3B C6 }                                  // cmp eax, esi
        $cmova_esi_eax = { 0F 47 F0 }                             // cmova esi, eax
        $call_ebx = { FF D3 }                                     // call ebx
        $cmp_dword_ptr_edi_dynamic_0 = { 83 BF ?? ?? ?? ?? 00 }   // cmp dword ptr [edi + dynamic offset], 0
        $je_dynamic_4 = { 0F 84 ?? ?? ?? ?? }                     // je with dynamic offset
        $mov_edx_dword_ptr_edi_dynamic = { 8B 97 ?? ?? ?? ?? }    // mov edx, dword ptr [edi + dynamic offset]
        $add_edx_ebx = { 03 D3 }                                  // add edx, ebx
        $mov_dword_ptr_esp_dynamic_edx = { 89 54 24 ?? }          // mov dword ptr [esp + dynamic offset], edx
        // More strings matching various unique or sequential instructions with potential dynamic values, including anti-debugging and evasion

    condition:
        all of them
}
